"""References: https://pmeerw.net/blog/programming/pefile-rewrite.html"""
import pefile

# Adjusts the given size to be aligned with the specified alignment.
def adjust_section_size(sz, align):
    if sz % align:
        sz = ((sz + align) // align) * align
    return sz

def create_new_section(pe, name, size, characteristics):
    # Get the last section to know where to place the new section.
    last_section = pe.sections[-1]

    # Create a new section object using the PE file's section header format.
    new_section = pefile.SectionStructure(pe.__IMAGE_SECTION_HEADER_format__)
    new_section.__unpack__(bytearray(new_section.sizeof()))

    # Set the new section's file offset immediately after the last section.
    new_section.set_file_offset(last_section.get_file_offset() + last_section.sizeof())
    new_section.Name = name.encode()

    # Calculate and set the new section's size and adjust address
    new_section.SizeOfRawData = adjust_section_size(size, pe.OPTIONAL_HEADER.FileAlignment)
    new_section.PointerToRawData = adjust_section_size(len(pe.__data__), pe.OPTIONAL_HEADER.FileAlignment)
    new_section.Misc = new_section.Misc_PhysicalAddress = new_section.Misc_VirtualSize = adjust_section_size(size, pe.OPTIONAL_HEADER.SectionAlignment)
    new_section.VirtualAddress = adjust_section_size(last_section.VirtualAddress + last_section.Misc_VirtualSize, pe.OPTIONAL_HEADER.SectionAlignment)

    # Set the new section's characteristics .
    new_section.Characteristics = characteristics

    return new_section

# Adds a jump to the original entry point (OEP) at the start of the new section.
def add_jump_to_oep(pe, new_section):
    # Calculate the relative jump from the new section to the original entry point.
    oep = pe.OPTIONAL_HEADER.AddressOfEntryPoint
    new_section_va = new_section.VirtualAddress
    reljmp = oep - (new_section_va + 5)  # 5 bytes for the jump instruction itself.

    # Ensure the relative jump is within the valid range for a 32-bit signed integer.
    if reljmp < -2147483648 or reljmp > 2147483647:
        raise OverflowError("Relative jump address out of range for a 32-bit signed integer.")

    # Construct the jump instruction with the calculated offset.
    jmp_instruction = 0xE9
    new_section_data = bytearray(new_section.SizeOfRawData)
    new_section_data[0] = jmp_instruction
    new_section_data[1:5] = (reljmp).to_bytes(4, byteorder='little', signed=True)

    return new_section_data

#32 bit tested only
pe = pefile.PE('./putty.exe')
new_section = create_new_section(pe, '.newsec', 100, 0x60000020) # Characteristics: readable, executable, contains code
new_section_data = add_jump_to_oep(pe, new_section)

# Increase the size of the image 
pe.OPTIONAL_HEADER.SizeOfImage += adjust_section_size(100, pe.OPTIONAL_HEADER.SectionAlignment)
# Increment the number of sections
pe.FILE_HEADER.NumberOfSections += 1
# Append the new section to the list of sections and the new section's data to the end of the PE file's data.
pe.sections.append(new_section)
pe.__structures__.append(new_section)
pe.__data__ = bytearray(pe.__data__) + new_section_data

pe.write('./putty_bt1.exe')
